# Java 특징

## 호환성이 높은 언어
- 자바(Java)는 JVM(Java Virtual Machine) 위에서 돌아가기 때문에 운영체제(OS)의 종류에 상관없이 실행되게 됩니다. 

- C언어의 경우에는 운영체제의 종류에 따라서 int형의 크기가 달라지기도 하지만 Java의 경우에는 모두 동일한 JVM환경에서 실행이 되어서 그렇습니다.

## [객체지향 프로그래밍(OOP)](#OOP)
- 객체지향(Object Oriented Programing)이다.
- 현실 세계에 인지 할 수 있는 모든것을 개채로 만들어 표현한 방법론
- 간단하게 말해 객체지향 프로그래밍 언어는 하나의 기능을 객체로 만들고, 이러한 **객체**들을 결합해서 **하나의 프로그램**을 만드는 것이다.

ex)
```
노트북을 예로들면

노트북 = 완성된 프로그램

CPU, 그래픽카드, 등등 =객체
```

## 함수적 스타일링 코딩을 지원
- 자바는 함수 프로그래밍을 위해 람다식을 자바 8부터 지원하고 있습니다.

- 람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬워지고, 코드가 간결해집니다.

## 메모리를 자동으로 관리
- C언어는 메모리에 생성된 객체를 제거하기 위해 개발자가 직접 코드를 작성해야 합니다.

- 자바는 개발자가 직접 메모리에 접근할 수 없도록 설계가 되어 있지만, 메모리는 자바가 직접 관리하게 됩니다.

- 객체 생성 시 자동적으로 메모리 영역을 찾아가서 할당하고, 사용이 완료되면 쓰레기수집기(Garbage Collector)를 샐행 시켜 자동적으로 사용하지 않는 객체를 제거합니다.

## 다양한 에플리케이션 개발
- 자바는 JVM을 사용함으로써 윈도우, 리눅스, 유닉스등 다양한 OS체제에서 실행되는 프로그램을 개발이 가능합니다.

- 단순한 콘솔 프로그램부터 클라이언트용 윈도우 애플리케이션, 서버용 웹 애플리케이션 모바일까지 모두 가능합니다.

## 멀티스레드 구현
- 하나의 프로그램이 동시에 여러 작업을 처리해야하는 경우, 그리고 대용량 작업을 빨리 처리하기 위해 서브 작업으로 분리해서 병렬 처리하려면 멀티스레드 프로그래밍이 필요합니다.

- 자바는 쓰레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 관계없이 멀티 스레드를 쉽게 구현이 가능합니다.

## 동적 로딩(Dynamic Loading)지원
- 자바 애플리케이션은 여러개의 객체가 서로 연결되어 실행되는데, 이객체들은 클래스로부터 실행이됩니다.

- 애플리케이션이 실행될 때 모든 객체가 실행되지 않고, 객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성합니다.

- 개발 후 유지보수가 발생하더라도 해당 클래스만 수정하면되고 전체적으로 다시 컴파일링을 할 필요가 없습니다.

## 오픈소스 라이브러리가 많다
- 유료화가 일부 진행되었지만, 자바는 오픈소스 언어이고 자바를 이용해서 전 세계에서 만들어진 라이브러리들이 굉장히 많습니다.

- 때문에 애플리케이션을 만들 때 오픈소스를 참고한다면 시간비용 절약이 가능합니다.

## 함수적 스타일링

### 람다식이란?
- 자바에서 함수형을 프로그래밍 하기 위해 자바8부터 지원된 개념

- 람다식은 **익명함수**를 생성하기 위한 식으로 코드가 간결, 병렬처리 가능, 컬렉션 요소를 필터링하거나 매핑가능해 결과를 쉽게 집계 가능
    - **익명함수**란 함수의 이름이 없는 함수로, 익명함수들은 모두 **1급 객체**다.
    - **1급 객체**인 함수는 변수처럼 사용이 가능하고 매게 변수로 전달이 가능한 특징이 있다.
        - **1급 객체**란?
            - 변수나 데이터 구조안에 담을 수 있다.
            - 파라미터로 전달 할 수 있다.
            - 반환값으로 사용할 수 있다.
            - 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.

#### 특징
- 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
- 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

#### 장점
1. 코드를 간결하게 만들 수 있다.
2. 식에 개발자의 의도가 명확하게 드러나 가독성이 높아진다.
3. 함수를 만드는 과정없이 한번에 처리할 수있어 생산성이 높아진다.
4. 병렬프로그래밍이 용이하다.

#### 단점
1. 람다를사용하면서 무명함수는 재사용이 불가능하다.
2. 디버깅이 어렵다.
3. 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
4. 재귀로 만들경우 부적합하다.

## 메모리

### Stack
- Stack은 Heap 객체의 참조 실제 값 자체를 갖는 데이터(Java 기본형)를 저장한다.
- 해당 객체는 scope 범위에서만 사용된다.
- 전역 변수가 아닌 지역 변수가 어떤 함수 내에서 stack에 할당되면 다른 함수에서는 접근할 수 없다.
- 자바의 Stack 메모리는 스레드당 할당된다. **스레드**가 생성되고 시작될 때 스레드는 자신의 Stack 메모리를 갖고, 다른 스레드 Stack 메모리에 접근할 수 없다. 
    - **스레드**란?
        - 메모리를 할당받아 실행 중인 프로그램을 프로세스라고 한다.
        - 프로세스 내의 명령어 블록으로 시작점과 종료점을 가진다.
        - 실행중에 멈출 수 있고, 동시에 수행이 가능하다.
        - 어떠한 프로그램내에서 특히 프로세스 내에서 실행되는 흐름의 단위

### Heap
- Heap 영역은 메모리에 실제 객체를 저장
- Heap 영역은 주로 긴 생명주기를 가지는 데이터들이 저장
- 모든 Object타입(Integer, String, ArrayList, HashMap등)은 Heap영역에 생성
- Heap 영역에 있는 Object들을 가리키는 레퍼런스 변수가 Stack에 저장

- String은 내부적으로 new 생성자를 통해 메모리 할당, 때문에 Heap에 충분한 여유공간이 있는지 확인하고, 메모리에 String타입 객체를 만들고 **참조 변수(주소)**를 통해 해당객체로 접근

### Garbage Collection
- 불필요한 메모리를 삭제해주는 것
- System.gc()를 통해 호출은 되지만, 해당 메소드를 호출하는 것은 시스템 성능에 큰 영향을 주어서 절대 호출해서는 안됨

#### 동작 방식
1. Stop The World
    - JVM이 애플리케이션을 실행을 멈추는 작업
    - GC를 실행하는 쓰레드를 제외하고 모든 쓰레드들의 작업이 중단되고, GC완료후 재게
    - JVM에서도 이런 문제를 해결하기위해 다양한 실행 옵션을 제공 중

2. Mark and Sweep
    - Mark : 사용되는 메모리와 사용하지 않는 메모리 식별하는 작업
    - Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

    - 1번을 통해 모든 작업을 중단시키면, GC는 변수, 객체를 스캔하면서 각각이 어떤 객체를 참고하는지 탐색한다. 그리고 **사용되고 있는 메모리**를 식별, 이과정을 **Mark**라고 한다.

    - 이후 **Mark되지 않은 객체들을 메모리에서 제거** 이것이 **Sweep**이다.

# OOP

## OOP(Object Oriented Programming)
 - 객체를 기준으로 나누어 구현(Java는 부분 단위가 Class)
 - 간단하게 말하면 객체 지향 프로그래밍 언어는 하나의 기능(class)을 객체(object)로 만들고, 이러한 객체(object)들을 결합해서 하나의 프로그램을 만드는 것이다.
 - 예를 들고 설명하자면 핸드폰을 만드는 설계도는 Class인 것이고, 설계도로 만든 핸드폰이 Object인 것 이다.
 - 현실세계의 객체들을 시스템화 하는 방법론

## Object(객체)
 - 우리가 인식할 수 있는 모든 것이 객체다
 - 객체의 식별성(identification), 상태(state)의 행동(behavior)를 가지고 있다. 구체화(calss에게 받음)하는 형태의 프로그래밍이 OOP이다.

## Class
 - 객체를 정의하는 틀 or 설계도
 - 이곳에는 여러 객체를 생성하여 사용한다.
 - 클래스는 객체의 상태를 나타내는 필드(bean)와 객체의 행동(app)을 나타내는 메소드로 구성된다.
	- 메소드는 어떤 작업을 수행하기 위한 명령문의 집합

## abstraction(추상화)
 - 공통의 속성, 기능을 묶어서 이름을 붙이는 것
 - 추상화는 추상클래스, 인터페이스를 통해 구현한다.
	- 추상클래스 : 추상메소드를 하나 이상 포함한 추상 클래스, 인터페이스의 구현이 가능
	- 인터페이스 : 추상메소드만을 포함한 추상클래스, 다중 상속 가능, 추상클래스 구현 불가능, private값을 가지지 못함
 - 추상화는 객체들의 공통된 특징을 파악하여 정의해 놓은 설계 기법이다.
 - Java 8부터는 인터페이스 안에 default 선언을 하면 body가 있는 메소드도 선언이 가능하다.

## Generalization(일반화)/Inheritance(상속)
 - 부모 클래스의 변수와 메소드를 자식 클래스가 전부 물려받는 것(상위 클래스의 모든 멤버를 하위 클래스가 물려받는 것)
 - 재사용성과 코드의 간결성 향상(코드의 중복성을 없애기 위함)
 - 중복이 많다면 유지보수에서도 많은 비용이 발생한다.
	- 자식 클래스 설계시 멤버를 미리 부모 클래스에 작성하면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됨
	- 이를 토대로 클래스간의 계층적 관계를 구성하고 다형성의 문법적 토대를 마련함

## Specialization(구체적)/전문화
 - 상위 클래스 유형을 하위 클래스 유형으로 변환하는 것을 말한다.
 - 일반적인 형식에서 특정 형식으로 바뀌는 것으로 범위가 좁혀지는데 이를 다운캐스팅이라고 한다.
 - 자바컴파일러가 구체적 캐스팅을 요청하는데 이것이 명시적 캐스팅이라고 한다.

## Realization(실체화)
 - 추상화형태의 객체를 상속하여 자신이 사용하고자하는 구현방법에 따라 오버라이딩 하여 내용을 완성하는 것
 - 인터페이스의 추상메소드를 오버라이딩해서 완성시킴
 
## Association(연관)
 - 객체 또는 클래스가 다른 객체 또는 클래스와 의미의 관계를 가질 수 있다.
	 - 집합연관(Aggregation)
		- 전체/부분 관계를 모델링 하는 경우 한 클래스는 더큰 것을 대표하고, 그것은 더 작은것들로 이루어져 있다.
	 - 복합연관(Compositon)
		- 단순한 집합연관은 전적으로 개념적이며 전체와 부분을 구분하는 것 이상의 어떤 것도 수행하지 않는다.

## Dependency(의존성)
 - A클래스 기능을 수행하기 위해 B클래스의 객체를 필요할 때, A클래스는 B클래스의 의존성을 가진다. 이것이 의존성 주입이다.
 - 의존성 주입은 내부에서 인스턴스를 생성하는 것이 아닌, 외부에서 주입하는 것이다.
	- 의존성을 외부에서 주입받으면 이런 장점을 가진다.
	- 코드의 재활용성이 높아짐
	- 단위테스트가 용이해짐
	- 객체 간의 의존성을 줄여줌
	- 객체 간의 결합도를 낮춰줌

## Polymorphism(다형성)
 - Poly(다양한) + morphism(변형)의 합성어
 - 하나의 객체가 여러가지 타입을 가질 수 있는 것
 - 자바에서는 한 레퍼런스 변수가 다른 형태의 객체를 참조 가능 한 것을 말한다.
 - 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅등의 방법이 있다.
	- 오버라이딩 : 부모클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메소드를 자식클래스에서 다시 재정의해서 사용하는 것
	- 오버로딩 : 같은 이름의 메소드를 사용하지만 메소드마다 다른용도로 사용해 그 결과를 다르게 구현하는 것
	- 오버로딩이 가능하려면 메소드끼리 이름은 같지만 매개변수갯수나 데이터타입이 달라야 한다.

## Encapuslation /절차은익/ 정보은익(캡슐화)
 - 객체의 변수 및 메소드를 외부객체가 함부로 건드리지 못하도록 감싸는 개념
 - 때문에 클래스를 우리가 만들 때 이 클래스에서 만들어진 객체가 특정 목적을 잘 수행할 수 있도록 사용할 변수와 그 변수를 가지고 메소드를 관련성이 있도록 구성해야 한다.
 - 캡슐화 하는 목적은 정보은닉이 주를 이루는데, 유저정보가 public으로 선언되어 있다면, 아무나 접근이 가능해 유저정보를 변경 할 수있다. 그렇게 private로 데이터를 접근을 제한해야한다.
 이렇게 보호된 변수는 getter나 setter 등의 메소드를 통해서만 간접적으로 접근이 가능해진다.
 - public : 어디서든 접근가능
 - private : 해당 클래스에서만 접근이 가능함
 - protected : 같은 패키지 내에서만 접근이 가능함
 - 캡슐화와 정보은닉을 묶어서 말하는 경우도 있지만, 정보은닉은 캡슐화에서 파생된 보조 개념이고 캡슐화 != 정보은닉이다.
