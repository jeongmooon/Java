# Java 특징

## 호환성이 높은 언어
- 자바(Java)는 JVM(Java Virtual Machine) 위에서 돌아가기 때문에 운영체제(OS)의 종류에 상관없이 실행되게 됩니다. 

- C언어의 경우에는 운영체제의 종류에 따라서 int형의 크기가 달라지기도 하지만 Java의 경우에는 모두 동일한 JVM환경에서 실행이 되어서 그렇습니다.

## 객체지향 프로그래밍(OOP)
- 객체지향(Object Oriented Programing)이다.

- 간단하게 말해 객체지향 프로그래밍 언어는 하나의 기능을 객체로 만들고, 이러한 **객체**들을 결합해서 **하나의 프로그램**을 만드는 것이다.

ex)
```
노트북을 예로들면

노트북 = 완성된 프로그램

CPU, 그래픽카드, 등등 =객체
```

## 함수적 스타일링 코딩을 지원
- 자바는 함수 프로그래밍을 위해 람다식을 자바 8부터 지원하고 있습니다.

- 람다식을 사용하면 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬워지고, 코드가 간결해집니다.

## 메모리를 자동으로 관리
- C언어는 메모리에 생성된 객체를 제거하기 위해 개발자가 직접 코드를 작성해야 합니다.

- 자바는 개발자가 직접 메모리에 접근할 수 없도록 설계가 되어 있지만, 메모리는 자바가 직접 관리하게 됩니다.

- 객체 생성 시 자동적으로 메모리 영역을 찾아가서 할당하고, 사용이 완료되면 쓰레기수집기(Garbage Collector)를 샐행 시켜 자동적으로 사용하지 않는 객체를 제거합니다.

## 다양한 에플리케이션 개발
- 자바는 JVM을 사용함으로써 윈도우, 리눅스, 유닉스등 다양한 OS체제에서 실행되는 프로그램을 개발이 가능합니다.

- 단순한 콘솔 프로그램부터 클라이언트용 윈도우 애플리케이션, 서버용 웹 애플리케이션 모바일까지 모두 가능합니다.

## 멀티스레드 구현
- 하나의 프로그램이 동시에 여러 작업을 처리해야하는 경우, 그리고 대용량 작업을 빨리 처리하기 위해 서브 작업으로 분리해서 병렬 처리하려면 멀티스레드 프로그래밍이 필요합니다.

- 자바는 쓰레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 관계없이 멀티 스레드를 쉽게 구현이 가능합니다.

## 동적 로딩(Dynamic Loading)지원
- 자바 애플리케이션은 여러개의 객체가 서로 연결되어 실행되는데, 이객체들은 클래스로부터 실행이됩니다.

- 애플리케이션이 실행될 때 모든 객체가 실행되지 않고, 객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성합니다.

- 개발 후 유지보수가 발생하더라도 해당 클래스만 수정하면되고 전체적으로 다시 컴파일링을 할 필요가 없습니다.

## 오픈소스 라이브러리가 많다
- 유료화가 일부 진행되었지만, 자바는 오픈소스 언어이고 자바를 이용해서 전 세계에서 만들어진 라이브러리들이 굉장히 많습니다.

- 때문에 애플리케이션을 만들 때 오픈소스를 참고한다면 시간비용 절약이 가능합니다.

# 용어 정리

## 객체지향언어(OOP)

1. 상속(Inheritance)
    - 부모 클래스의 변수와 메소드를 자식 클래스가 전부 물려받는 것

2. 캡슐화(Encapsulation, Information Hiding)
    - 객체의 변수 및 메소드를 외부객체가 함부로 건드리지 못하도록 감싸는 개념
    - 클래스의 getter/setter 등을 통해 은닉

3. 다형성(Polymorphism)
    - Poly(다양한) + morphism(변형) 합성어
    - 하나의 객체가 여러가지 타입을 가질 수 있는 것
    - 자바에서는 한 레퍼런스 변수가 다른 형태의 객체를 참조 가능 한 것을 말함
    -  오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅등의 방법이 있음

4. 추상화(Abstraction)
    - 자바에서 공통의 속성, 기능을 묶어 이름을 붙이는 것
    - 자바에서 추상화는 추상클래스, 인터페이스를 통해 구현
        - 추상클래스 : 추상메소드를 하나 이상 포함한 추상 클래스
        - 인터페이스 : 추상메소드만을 포함한 추상클래스, 다중 상속 가능
    - Java 8부터는 인터페이스 안에 default 선언을 하면 body가 있는 메소드도 선언이 가능
5. 모듈
6. 클래스(class)
    - 객체를 정의하는 틀 or 설계도
    - 이곳에는 여러 객체를 생성하여 사용한다.
    - 클래스는 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성된다.
        - 메소드는 어떤 작접을 수행하기 위한 명령문의 집합
7. 객체(object)
    - 간단하게 말하면 우리가 인식할 수 있는 사물과 같은 것
    - 객체의 상태(state)의 행동(behavior)을 구체화하는 형태의 프로그래밍이 OOP(객체지향프로그래밍)
## 함수적 스타일링

### 람다식이란?
- 자바에서 함수형을 프로그래밍 하기 위해 자바8부터 지원된 개념

- 람다식은 **익명함수**를 생성하기 위한 식으로 코드가 간결, 병렬처리 가능, 컬렉션 요소를 필터링하거나 매핑가능해 결과를 쉽게 집계 가능
    - **익명함수**란 함수의 이름이 없는 함수로, 익명함수들은 모두 **1급 객체**다.
    - **1급 객체**인 함수는 변수처럼 사용이 가능하고 매게 변수로 전달이 가능한 특징이 있다.
        - **1급 객체**란?
            - 변수나 데이터 구조안에 담을 수 있다.
            - 파라미터로 전달 할 수 있다.
            - 반환값으로 사용할 수 있다.
            - 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.
#### 특징
- 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
- 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

#### 장점
1. 코드를 간결하게 만들 수 있다.
2. 식에 개발자의 의도가 명확하게 드러나 가독성이 높아진다.
3. 함수를 만드는 과정없이 한번에 처리할 수있어 생산성이 높아진다.
4. 병렬프로그래밍이 용이하다.

#### 단점
1. 람다를사용하면서 무명함수는 재사용이 불가능하다.
2. 디버깅이 어렵다.
3. 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
4. 재귀로 만들경우 부적합하다.

## 메모리

### Stack
- Stack은 Heap 객체의 참조 실제 값 자체를 갖는 데이터(Java 기본형)를 저장한다.
- 해당 객체는 scope 범위에서만 사용된다.
- 전역 변수가 아닌 지역 변수가 어떤 함수 내에서 stack에 할당되면 다른 함수에서는 접근할 수 없다.
- 자바의 Stack 메모리는 스레드당 할당된다. **스레드**가 생성되고 시작될 때 스레드는 자신의 Stack 메모리를 갖고, 다른 스레드 Stack 메모리에 접근할 수 없다. 
    - **스레드**란?
        - 메모리를 할당받아 실행 중인 프로그램을 프로세스라고 한다.
        - 프로세스 내의 명령어 블록으로 시작점과 종료점을 가진다.
        - 실행중에 멈출 수 있고, 동시에 수행이 가능하다.
        - 어떠한 프로그램내에서 특히 프로세스 내에서 실행되는 흐름의 단위

### Heap
- Heap 영역은 메모리에 실제 객체를 저장
- Heap 영역은 주로 긴 생명주기를 가지는 데이터들이 저장
- 모든 Object타입(Integer, String, ArrayList, HashMap등)은 Heap영역에 생성
- Heap 영역에 있는 Object들을 가리키는 레퍼런스 변수가 Stack에 저장

- String은 내부적으로 new 생성자를 통해 메모리 할당, 때문에 Heap에 충분한 여유공간이 있는지 확인하고, 메모리에 String타입 객체를 만들고 **참조 변수(주소)**를 통해 해당객체로 접근

### Garbage Collection
- 불필요한 메모리를 삭제해주는 것
- System.gc()를 통해 호출은 되지만, 해당 메소드를 호출하는 것은 시스템 성능에 큰 영향을 주어서 절대 호출해서는 안됨

#### 동작 방식
1. Stop The World
    - JVM이 애플리케이션을 실행을 멈추는 작업
    - GC를 실행하는 쓰레드를 제외하고 모든 쓰레드들의 작업이 중단되고, GC완료후 재게
    - JVM에서도 이런 문제를 해결하기위해 다양한 실행 옵션을 제공 중

2. Mark and Sweep
    - Mark : 사용되는 메모리와 사용하지 않는 메모리 식별하는 작업
    - Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

    - 1번을 통해 모든 작업을 중단시키면, GC는 변수, 객체를 스캔하면서 각각이 어떤 객체를 참고하는지 탐색한다. 그리고 **사용되고 있는 메모리**를 식별, 이과정을 **Mark**라고 한다.

    - 이후 **Mark되지 않은 객체들을 메모리에서 제거** 이것이 **Sweep**이다.